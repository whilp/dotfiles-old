#!/usr/bin/env python
import cmd
import glob
import logging
import os
import readline
import time

from datetime import datetime
from itertools import takewhile

from cli.log import LoggingApp

try:
    import codecs
except ImportError:
    codecs = None

LAST_LINES = 10
LEVEL = logging.DEBUG

class Loop(cmd.Cmd):
    settable = ("dir", "datefmt", "msgfmt", "sep")

    def __init__(self, all=False, dir=".", datefmt="%Y-%m-%d", 
            msgfmt="%(message)s", sep="\t", prompt="> ", *args, **kwargs):
        cmd.Cmd.__init__(self, *args, **kwargs)
        self.all = all
        self.dir = dir
        self.datefmt = datefmt
        self.msgfmt = msgfmt
        self.sep = sep
        self._prompt = prompt
        self.lasttag = ""

    @property
    def prompt(self):
        data = {
            "lasttag": getattr(self, "lasttag", ""),
            "lastdate": getattr(self, "lastdate", ""),
            "date": self.date,
        }
        return self._prompt % data

    @property
    def date(self):
        return time.strftime(self.datefmt)

    def complete(self, text, state):
        #print "complete %r, %r" % (text, line)
        matches = ["#" + x.lstrip("./") for x in 
            glob.glob(os.path.join(self.dir, text) + "*")]

        try:
            return matches[state]
        except IndexError:
            return None

    def default(self, line):
        fields = line.split()
        tags = [fields.pop(0)]
        tags.extend(takewhile(lambda x: x.startswith("#"), 
            [f for f in fields if f]))
        if not tags:
            return
        elif not self.all:
            tags = tags[:1]

        updatelast = True
        for tag in tags:
            tag = tag.lstrip("#")
            if updatelast:
                self.lasttag = tag
                self.lastdate = self.date
                updatelast = False
            self.append(tag, line)

    def append(self, fname, line):
        data = {
            "message": line,
            "date": self.date,
            "sep": self.sep,
        }
        message = self.msgfmt % data
        fname = os.path.join(self.dir, fname)
        try:
            os.makedirs(self.dir)
        except OSError, e:
            if e.errno != 17:
                raise
                
        if not fname.startswith(self.dir):
            return
        with open(fname, 'a') as f:
            f.write(message)

    def do_set(self, line):
        name, rest = line.split(None, 1)
        if name in self.settable:
            setattr(self, name, rest)

    # Exit and its synonyms.
    def do_exit(self, line):
        return True

    do_EOF = do_exit
    do_q = do_exit

class notes(LoggingApp):
    defaults = {
        "prompt": "%(lastdate)s %(lasttag)s > ",
        "dir": ".",
        "sep": "\t",
        "datefmt": "%Y-%m-%dT%H:%M:%S",
        "msgfmt": "%(date)s%(sep)s%(message)s\n",
    }
    
    def main(self):
        loop = Loop(
            all=self.params.all,
            dir=self.params.dir[0],
            datefmt=self.params.datefmt,
            msgfmt=self.params.msgfmt,
            prompt=self.params.prompt,
            sep=self.params.sep)
        loop.cmdloop()
        self.stdout.write('\n')

    def setup(self):
        LoggingApp.setup(self)
        self.add_param("-a", "--all", default=False, action="store_true",
            help="log note to separate files for each tag "
                "(default: only the first tag)")
        self.add_param("-d", "--datefmt", default=self.defaults["datefmt"],
            help="strftime(3) date format (default: %r)" % 
                self.defaults["datefmt"].replace("%", "%%"))
        self.add_param("-m", "--msgfmt", default=self.defaults["msgfmt"],
            help="logging.Formatter message format (default: %r)" % 
                self.defaults["msgfmt"].replace("%", "%%"))
        self.add_param("-p", "--prompt", default=self.defaults["prompt"],
            help="interpreter prompt (default: %r)" % 
                self.defaults["prompt"].replace("%", "%%"))
        self.add_param("-S", "--sep", default=self.defaults["sep"],
            help="record separator (default: %(sep)r)" % self.defaults)
        self.add_param("dir", nargs=1, default=self.defaults["dir"],
            help="notes working directory (default: %(dir)s)" % self.defaults)

if __name__ == "__main__":
    notes().run()
