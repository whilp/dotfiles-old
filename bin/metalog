#!/usr/bin/env python

import logging
import optparse
import os
import sys
import time

from itertools import dropwhile
from optparse import Option

try:
    from logging import NullHandler
except ImportError:
    class NullHandler(logging.Handler):
        
        def emit(self, record):
            pass

logname = "metalog"
logging.getLogger(logname).addHandler(NullHandler())

def getlogger(name, level, stream,
        fmt="%(asctime)s %(name)s %(message)s",
        datefmt="%Y-%m-%dT%H:%M:%S"):
    logger = logging.getLogger(name)
    logger.setLevel(level)

    handler = logging.StreamHandler(stream)
    formatter = logging.Formatter(fmt, datefmt)
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    return logger

def parseargs(args, needsargs=False):
    parser = optparse.OptionParser()
    parser.allow_interspersed_args = False

    # Global options.
    parser.add_option("-q", "--quiet", dest="quiet",
        default=0, action="count",
        help="decrease the logging verbosity")
    parser.add_option("-s", "--silent", dest="silent",
        default=False, action="store_true",
        help="silence the logger")
    parser.add_option("-v", "--verbose", dest="verbose",
        default=0, action="count",
        help="increase the logging verbosity")

    (opts, args) = parser.parse_args()
    if not args and needsargs:
        parser.print_help()
        sys.exit(0)
    else:
        return (opts, args)

class BaseWatcher(object):
    format = "%s"
    
    def __init__(self, interval=1):
        self.interval = interval
        self.log = logging.getLogger("%s.%s" % 
            (logname, self.__class__.__name__))

    def getline(self, fileobj, parse):
        line = fileobj.readline()
        if not line or not line.endswith("\n"):
            return
        return  parse(line)
    
    def tail(self, fname, parse, interval=1):
        f = None
        while True:
            if f is None:
                f = open(fname)
                f.seek(0, 2)

            size = os.fstat(f.fileno()).st_size
            if f.tell() > size:
                f = None
                continue

            line = self.getline(f, parse)
            if not line:
                time.sleep(interval)
                continue

            yield line

    def parse(self, line):
        return line

    def watch(self, fname):
        for line in self.tail(fname, self.parse, self.interval):
            self.log.info(self.format, line)

def main():
    (opts, args) = parseargs(sys.argv[1:], needsargs=True)
    level = logging.WARNING - ((opts.verbose - opts.quiet) * 10)
    if opts.silent:
        level = logging.CRITICAL + 1

    logger = getlogger(logname, level, sys.stderr)
            
    Watcher = BaseWatcher
    watcher = Watcher()
    fname = args[0]
    try:
        watcher.watch(fname)
    except (KeyboardInterrupt,), e:
        returned = None

    sys.exit(returned and returned or 0)

if __name__ == "__main__":
    main()
