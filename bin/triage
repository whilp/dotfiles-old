#!/usr/bin/env python
import logging
import os
import readline

from cmd import Cmd
from datetime import datetime

try:
    import codecs
except ImportError:
    codecs = None

DATE_FMT = "%Y-%m-%dT%H:%M:%S"
LAST_LINES = 10
LEVEL = logging.DEBUG
MSG_FMT = "%(asctime)s\t %(message)s"
PROMPT = "> "

class Triage(Cmd):
    prompt = PROMPT
    ignore = '#'

    def __init__(self, logger, logfile, out, *args, **kwargs):
        Cmd.__init__(self, *args, **kwargs)
        self.logger = logger
        self.log = self.logger.log
        self.logfile = logfile
        self.out = out

    def default(self, line):
        self.log(logging.DEBUG, line)

    def read(self, includes='', lines=10):
        f = open(self.logfile, 'r')

        # Seek to a point either end-1K or the beginning of the
        # file.
        size = os.fstat(f.fileno()).st_size
        index = size - 1024
        index = index > 0 or 0
        f.seek(index)

        lines = [l.partition('\t') for l in f.readlines()
				if l and
                l[0] not in self.ignore and
                includes in l][-lines:]
        f.close()

        lines = [(datetime.strptime(d, DATE_FMT), m.strip()) for d, p, m in lines]
        return lines

    def do_last(self, line):
        p = ''
        try:
            n = int(line or LAST_LINES)
        except ValueError:
            n = LAST_LINES
            p = line

        lines = [' '.join((d.strftime(DATE_FMT), m)) for d, m in self.read(p, n)]

        self.out.write('\n'.join(lines) + '\n')

    # Exit and its synonyms.
    def do_exit(self, line):
        return True

    do_EOF = do_exit
    do_q = do_exit

class ReloadingFileHandler(logging.FileHandler):

    def __init__(self, filename, mode='a', encoding=None):
        stream = self.open(filename, mode, encoding)
        logging.StreamHandler.__init__(self, stream)
        self.baseFilename = os.path.abspath(filename)
        self.mode = mode
        self.encoding = encoding
        self.size = 0

    def open(self, filename, mode='a', encoding=None):
        if codecs is None:
            encoding = None

        if encoding is None:
            stream = open(filename, mode)
        else:
            stream = codecs.open(filename, mode, encoding)

        return stream

    def emit(self, record):
        # Reopen the stream each time. This is slightly paranoid,
        # but useful.
        self.stream = self.open(self.baseFilename, self.mode, self.encoding)
        logging.FileHandler.emit(self, record)

if __name__ == "__main__":
    import sys

    try:
        logfile = sys.argv[1]
    except IndexError:
        logfile = "~/.triage"

    logfile = os.path.expanduser(logfile)
    logfile = os.path.abspath(logfile)

    # Set up logging.
    log = logging.getLogger("triage")
    log.setLevel(LEVEL)
    handler = ReloadingFileHandler(logfile)
    handler.setLevel(LEVEL)
    formatter = logging.Formatter(MSG_FMT, DATE_FMT)
    handler.setFormatter(formatter)
    log.addHandler(handler)

    triage = Triage(log, logfile, sys.stdout)
    triage.cmdloop()
